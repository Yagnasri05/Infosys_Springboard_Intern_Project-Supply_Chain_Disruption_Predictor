# -*- coding: utf-8 -*-
"""Milestone_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ekzBbWrCkOiWjOE1IoCeRzEX3Cle36m0
"""

!pip install flask-ngrok joblib scikit-learn pandas numpy

from google.colab import drive
drive.mount('/content/drive')

!pip install --upgrade scikit-learn

!pip install ipywidgets

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
import joblib
from flask import Flask, request, jsonify
from flask_ngrok import run_with_ngrok

# Load the dataset
data_path = '/content/drive/MyDrive/Product_risk_factorized_data.csv'  # Update path if necessary
df = pd.read_csv(data_path)

# Check the dataset
print("Dataset Loaded:")
print(df.head())

# Prepare data for predictive modeling
X = df[['Inventory Level', 'Lead Time (days)', 'News Sentiment', 'Textual Risk']]
y = df['Computed Risk Factor']
from sklearn.metrics import mean_squared_error

# Split data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train a predictive model (Random Forest)
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Evaluate the model
y_pred = model.predict(X_test)
rmse = mean_squared_error(y_test, y_pred)
print(f"Model RMSE: {rmse}")

# Save the model
joblib.dump(model, '/content/predictive_disruption_model.pkl')
print("Predictive disruption model saved.")

import pandas as pd
import joblib
from ipywidgets import widgets, interact, interact_manual

# Load the predictive model
model_path = '/content/predictive_disruption_model.pkl'  # Replace with your model path
model = joblib.load(model_path)

# Simulated inventory database
inventory = {
    "semiconductors": {
        "capacity": 1000,          # Maximum capacity
        "current_stock": 500,      # Current stock level
        "monthly_purchase": 200,   # Monthly incoming stock
        "monthly_sales": 250,      # Monthly outgoing stock
        "minimum_stock": 100,      # Minimum stock threshold
        "damaged_stock": 0,        # Stock lost due to damage
        "transport_delay": False,  # Flag for transport delay
        "selling_price": 15.0,     # Price per unit
        "cost_price": 10.0,        # Cost per unit
    }
}

# Ensure the model expects only these features
model_features = ["Inventory Level", "Lead Time (days)", "News Sentiment", "Textual Risk"]

# Prediction function
def predict_risk(inventory_level, lead_time, news_sentiment, textual_risk):
    """
    Predict risk factor and risk label based on input features.
    """
    data = {
        "Inventory Level": inventory_level,
        "Lead Time (days)": lead_time,
        "News Sentiment": news_sentiment,
        "Textual Risk": textual_risk,
    }
    # Predict risk factor
    risk_factor = model.predict(pd.DataFrame([data], columns=model_features))[0]
    # Assign risk label
    risk_label = (
        "High" if risk_factor >= 0.6 else "Medium" if risk_factor >= 0.3 else "Low"
    )
    print("\n--- Risk Prediction ---")
    print(f"Predicted Risk Factor: {risk_factor}")
    print(f"Risk Label: {risk_label}")

# Update inventory with alerts for stock levels
def update_inventory(product, new_stock):
    """
    Update inventory for the specified product and generate refined alerts.
    """
    if product in inventory:
        inventory[product]["current_stock"] += new_stock
        current_stock = inventory[product]["current_stock"]
        minimum_stock = inventory[product]["minimum_stock"]
        capacity = inventory[product]["capacity"]

        print("\n--- Inventory Updated ---")
        print(f"Product: {product}")
        print(f"Current Stock: {current_stock}")

        # Alerts based on stock levels
        if current_stock < minimum_stock:
            print(f"ALERT: Current stock ({current_stock}) is below the minimum threshold ({minimum_stock}). Restock immediately!")
        elif current_stock > capacity:
            print(f"WARNING: Current stock ({current_stock}) exceeds capacity ({capacity}). Consider reducing stock.")
        else:
            print("INFO: Stock levels are within a healthy range.")

        # Alerts for incoming vs. outgoing stock
        if inventory[product]["monthly_purchase"] < inventory[product]["monthly_sales"]:
            print("WARNING: Monthly incoming stock is less than outgoing sales. Inventory may deplete soon.")
    else:
        print("Error: Product not found.")

# Log damaged stock
def log_damage(product, damaged_quantity):
    """
    Log and handle damaged stock for a product.
    """
    if product in inventory:
        inventory[product]["damaged_stock"] += damaged_quantity
        inventory[product]["current_stock"] -= damaged_quantity
        print("\n--- Damaged Stock Logged ---")
        print(f"Product: {product}")
        print(f"Damaged Stock: {damaged_quantity}")
        print(f"Updated Current Stock: {inventory[product]['current_stock']}")
        if inventory[product]["current_stock"] < inventory[product]["minimum_stock"]:
            print(f"ALERT: Current stock is below the minimum threshold ({inventory[product]['minimum_stock']}). Restock immediately!")
    else:
        print("Error: Product not found.")

# Log transport delays
def log_transport_delay(product, delay_days):
    """
    Handle transport delays and provide alerts.
    """
    if product in inventory:
        inventory[product]["transport_delay"] = True
        print("\n--- Transport Delay Logged ---")
        print(f"Product: {product}")
        print(f"Delay Duration: {delay_days} days")
        print("WARNING: Transport delay will affect inventory replenishment.")
    else:
        print("Error: Product not found.")

# Monitor sales performance
def log_sales(product, sales_quantity):
    """
    Track sales and generate alerts for halted or reduced sales.
    """
    if product in inventory:
        inventory[product]["monthly_sales"] = sales_quantity
        print("\n--- Sales Logged ---")
        print(f"Product: {product}")
        print(f"Updated Monthly Sales: {sales_quantity}")
        if sales_quantity == 0:
            print("ALERT: Sales halted! Investigate immediately.")
        elif sales_quantity < inventory[product]["monthly_purchase"]:
            print("WARNING: Sales are below expected levels. Monitor trends.")
    else:
        print("Error: Product not found.")

# View inventory status
def view_inventory():
    """
    Display the current inventory status along with additional details.
    """
    print("\n--- Current Inventory ---")
    for product, details in inventory.items():
        print(f"Product: {product}")
        for key, value in details.items():
            print(f"  {key}: {value}")

        # Stock level alerts
        if details["current_stock"] < details["minimum_stock"]:
            print(f"  ALERT: Stock critically low for {product}! Restock immediately.")
        elif details["current_stock"] > details["capacity"]:
            print(f"  WARNING: Stock exceeds capacity for {product}. Reduce inventory.")
        else:
            print(f"  INFO: Stock levels for {product} are healthy.")

# Interactive widgets
# Risk Prediction
interact(
    predict_risk,
    inventory_level=widgets.FloatSlider(min=0, max=1, step=0.1, value=0.5, description="Inventory Level"),
    lead_time=widgets.FloatSlider(min=0, max=100, step=1, value=30, description="Lead Time (days)"),
    news_sentiment=widgets.FloatSlider(min=-1, max=1, step=0.1, value=0, description="News Sentiment"),
    textual_risk=widgets.FloatSlider(min=-1, max=1, step=0.1, value=0, description="Textual Risk"),
)

# Update Inventory
interact_manual(
    update_inventory,
    product=widgets.Text(value="semiconductors", description="Product:"),
    new_stock=widgets.IntText(value=0, description="New Stock:"),
)

# Log Damaged Stock
interact_manual(
    log_damage,
    product=widgets.Text(value="semiconductors", description="Product:"),
    damaged_quantity=widgets.IntText(value=0, description="Damaged Quantity:"),
)

# Log Transport Delay
interact_manual(
    log_transport_delay,
    product=widgets.Text(value="semiconductors", description="Product:"),
    delay_days=widgets.IntText(value=0, description="Delay Days:"),
)

# Log Sales Performance
interact_manual(
    log_sales,
    product=widgets.Text(value="semiconductors", description="Product:"),
    sales_quantity=widgets.IntText(value=0, description="Sales Quantity:"),
)

# View Inventory
interact_manual(view_inventory)

import matplotlib.pyplot as plt

def plot_inventory_status():
    """
    Visualize current inventory status using a bar chart.
    """
    products = list(inventory.keys())
    current_stocks = [inventory[product]["current_stock"] for product in products]
    capacities = [inventory[product]["capacity"] for product in products]
    minimum_stocks = [inventory[product]["minimum_stock"] for product in products]

    x = range(len(products))

    plt.bar(x, current_stocks, width=0.4, label="Current Stock", color='blue')
    plt.bar(x, capacities, width=0.4, label="Capacity", color='green', alpha=0.6, bottom=current_stocks)
    plt.bar(x, minimum_stocks, width=0.4, label="Minimum Stock", color='red', alpha=0.7)

    plt.xlabel("Products")
    plt.ylabel("Stock Levels")
    plt.title("Inventory Status")
    plt.xticks(x, products)
    plt.legend()
    plt.show()

# Call the function to plot
plot_inventory_status()

import sqlite3

# Initialize the SQLite database
conn = sqlite3.connect('inventory.db')
cursor = conn.cursor()

# Create a table for inventory
cursor.execute('''
CREATE TABLE IF NOT EXISTS inventory (
    product TEXT PRIMARY KEY,
    capacity INTEGER,
    current_stock INTEGER,
    monthly_purchase INTEGER,
    monthly_sales INTEGER,
    minimum_stock INTEGER,
    damaged_stock INTEGER,
    transport_delay INTEGER,
    selling_price REAL,
    cost_price REAL
)
''')

# Insert sample data
cursor.execute('''
INSERT OR REPLACE INTO inventory (product, capacity, current_stock, monthly_purchase, monthly_sales, minimum_stock, damaged_stock, transport_delay, selling_price, cost_price)
VALUES ('semiconductors', 1000, 500, 200, 250, 100, 0, 0, 15.0, 10.0)
''')
conn.commit()

# Function to fetch inventory from the database
def fetch_inventory():
    cursor.execute("SELECT * FROM inventory")
    rows = cursor.fetchall()
    for row in rows:
        print(row)

fetch_inventory()
conn.close()

def auto_restock(product):
    """
    Automatically restock a product if current stock falls below minimum threshold.
    """
    if product in inventory:
        current_stock = inventory[product]["current_stock"]
        minimum_stock = inventory[product]["minimum_stock"]
        capacity = inventory[product]["capacity"]

        if current_stock < minimum_stock:
            restock_amount = min(capacity - current_stock, minimum_stock * 2)
            inventory[product]["current_stock"] += restock_amount
            print(f"Auto-restocked {restock_amount} units for {product}.")
        else:
            print(f"No need to restock {product}. Stock levels are sufficient.")

# Example usage
auto_restock("semiconductors")