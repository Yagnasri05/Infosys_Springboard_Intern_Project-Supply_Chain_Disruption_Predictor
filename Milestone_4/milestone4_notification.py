# -*- coding: utf-8 -*-
"""Milestone4_Notification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/114K_DRAPIeFR5EaWTt6nLL9BFpyVL9l5
"""

!pip install gradio joblib scikit-learn pandas numpy ipywidgets

from google.colab import drive
drive.mount('/content/drive')

!pip install slack-sdk

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
import joblib
import sqlite3
import matplotlib.pyplot as plt
import gradio as gr
import os
import requests

# Load dataset
data_path = '/content/drive/MyDrive/Product_risk_factorized_data.csv'
df = pd.read_csv(data_path)

# Prepare data for predictive modeling
X = df[['Inventory Level', 'Lead Time (days)', 'News Sentiment', 'Textual Risk']]
y = df['Computed Risk Factor']

# Train-Test Split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train predictive model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Save model
model_path = '/content/predictive_disruption_model.pkl'
joblib.dump(model, model_path)

# Load predictive model
model_path = '/content/predictive_disruption_model.pkl'
model = joblib.load(model_path)

# SQLite Database Setup
db_path = 'inventory.db'
conn = sqlite3.connect(db_path)
cursor = conn.cursor()

# Initialize inventory
inventory = {
    "semiconductors": {
        "capacity": 1000,
        "current_stock": 500,
        "monthly_purchase": 200,
        "monthly_sales": 250,
        "minimum_stock": 100,
        "damaged_stock": 0,
        "transport_delay": False,
        "selling_price": 15.0,
        "cost_price": 10.0,
    }
}

# Model features
model_features = ["Inventory Level", "Lead Time (days)", "News Sentiment", "Textual Risk"]

SLACK_WEBHOOK_URL = 'https://hooks.slack.com/services/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'

# Function to send Slack notifications
def send_slack_message(message):
    payload = {
        "text": message
    }
    response = requests.post(SLACK_WEBHOOK_URL, json=payload)
    if response.status_code != 200:
        print(f"Failed to send Slack message: {response.text}")

# Functions
def predict_risk(inventory_level, lead_time, news_sentiment, textual_risk):
    """
    Predict risk factor and risk label.
    """
    data = {
        "Inventory Level": inventory_level,
        "Lead Time (days)": lead_time,
        "News Sentiment": news_sentiment,
        "Textual Risk": textual_risk,
    }
    risk_factor = model.predict(pd.DataFrame([data], columns=model_features))[0]
    risk_label = "High" if risk_factor >= 0.6 else "Medium" if risk_factor >= 0.3 else "Low"
    if risk_factor>=0.6:
      send_slack_message("WARNING: Risk is too high! Check all sources.")
    elif risk_factor>=0.3 and risk_factor<0.6:
      send_slack_message("The risk is medium, look into the details.")
    else:
      send_slack_message("Low Risk. All good. ")
    return f"Risk Factor: {risk_factor:.2f}", f"Risk Label: {risk_label}"

def update_inventory(product, new_stock):
    """
    Update inventory and provide alerts.
    """
    if product in inventory:
        inventory[product]["current_stock"] += new_stock
        alerts = []
        current_stock = inventory[product]["current_stock"]
        minimum_stock = inventory[product]["minimum_stock"]
        capacity = inventory[product]["capacity"]

        if current_stock < minimum_stock:
            alerts.append(f"ALERT: Stock below minimum ({minimum_stock}). Restock immediately!")
            send_slack_message(f"ALERT: Stock below minimum ({minimum_stock}). Restock immediately!")
        if current_stock > capacity:
            alerts.append(f"WARNING: Stock exceeds capacity ({capacity}). Consider reducing stock.")
            send_slack_message(f"WARNING: Stock exceeds capacity ({capacity}). Consider reducing stock.")
        if inventory[product]["monthly_purchase"] < inventory[product]["monthly_sales"]:
            alerts.append("WARNING: Monthly incoming stock is less than outgoing sales. Inventory may deplete soon.")
            send_slack_message("WARNING: Monthly incoming stock is less than outgoing sales. Inventory may deplete soon.")
        return inventory[product], "\n".join(alerts)
    return {}, "Error: Product not found."

def log_damage(product, damaged_quantity):
    """
    Log damaged stock and provide alerts.
    """
    if product in inventory:
        inventory[product]["damaged_stock"] += damaged_quantity
        inventory[product]["current_stock"] -= damaged_quantity

        alerts = [f"Damaged stock logged: {damaged_quantity} units for {product}."]
        if damaged_quantity > inventory[product]["capacity"] * 0.1:
            alerts.append("WARNING: High damage recorded! Investigate causes.")
            send_slack_message("WARNING: High damage recorded! Investigate causes.")
        if inventory[product]["current_stock"] < inventory[product]["minimum_stock"]:
            alerts.append("ALERT: Current stock is below the minimum threshold. Restock immediately!")
            send_slack_message("ALERT: Current stock is below the minimum threshold. Restock immediately!")
        return inventory[product], "\n".join(alerts)
    return {}, "Error: Product not found."

def log_transport_delay(product, delay_days):
    """
    Log transport delay and provide alerts.
    """
    if product in inventory:
        inventory[product]["transport_delay"] = True
        alerts = [f"Transport delay logged for {product}: {delay_days} days."]
        alerts.append("WARNING: Transport delay may impact inventory replenishment.")
        send_slack_message("WARNING: Transport delay may impact inventory replenishment.")
        return inventory[product], "\n".join(alerts)
    return {}, "Error: Product not found."

def log_sales(product, sales_quantity):
    """
    Log sales and provide alerts.
    """
    if product in inventory:
        inventory[product]["monthly_sales"] = sales_quantity
        alerts = [f"Monthly sales logged: {sales_quantity} units for {product}."]
        if sales_quantity > inventory[product]["current_stock"]:
            alerts.append("ALERT: Sales exceed current stock! Replenish inventory.")
            send_slack_message("ALERT: Sales exceed current stock! Replenish inventory.")
        elif sales_quantity < inventory[product]["monthly_purchase"] * 0.5:
            alerts.append("WARNING: Sales significantly below purchase levels. Investigate demand.")
            send_slack_message("WARNING: Sales significantly below purchase levels. Investigate demand.")
        return inventory[product], "\n".join(alerts)
    return {}, "Error: Product not found."

def auto_restock(product):
    if product in inventory:
        current_stock = inventory[product]["current_stock"]
        minimum_stock = inventory[product]["minimum_stock"]
        capacity = inventory[product]["capacity"]
        restock_data = {}

        if current_stock < minimum_stock:
            restock_amount = min(capacity - current_stock, minimum_stock * 2)
            restock_data["before"] = current_stock
            inventory[product]["current_stock"] += restock_amount
            restock_data["after"] = inventory[product]["current_stock"]
            log_action(product, "Auto-Restock", restock_amount, inventory[product]["current_stock"])
            return restock_data, f"Auto-restocked {restock_amount} units for {product}."
        else:
            return None, "Stock levels sufficient. No restocking required."
    return None, "Error: Product not found."

def view_inventory():
    """
    Display inventory details in tabular format.
    """
    df = pd.DataFrame.from_dict(inventory, orient="index")
    df.reset_index(inplace=True)
    df.rename(columns={"index": "Product"}, inplace=True)
    return df

def plot_inventory_status():
    """
    Visualize inventory status.
    """
    df = view_inventory()
    plt.figure(figsize=(10, 6))
    plt.bar(df["Product"], df["current_stock"], label="Current Stock", color="blue")
    plt.bar(df["Product"], df["capacity"], label="Capacity", color="green", alpha=0.5)
    plt.bar(df["Product"], df["minimum_stock"], label="Minimum Stock", color="red", alpha=0.7)
    plt.xlabel("Products")
    plt.ylabel("Stock Levels")
    plt.title("Inventory Status")
    plt.legend()
    plt.tight_layout()
    plt.savefig("inventory_status.png")
    return "inventory_status.png"

# Gradio Functions
def gradio_predict_risk(inventory_level, lead_time, news_sentiment, textual_risk):
    return predict_risk(inventory_level, lead_time, news_sentiment, textual_risk)

def gradio_update_inventory(product, new_stock):
    updated_inventory, alerts = update_inventory(product, new_stock)
    return updated_inventory, alerts

def gradio_log_damage(product, damaged_quantity):
    updated_inventory, alerts = log_damage(product, damaged_quantity)
    return updated_inventory, alerts

def gradio_log_transport_delay(product, delay_days):
    updated_inventory, alerts = log_transport_delay(product, delay_days)
    return updated_inventory, alerts

def gradio_log_sales(product, sales_quantity):
    updated_inventory, alerts = log_sales(product, sales_quantity)
    return updated_inventory, alerts

def gradio_view_inventory():
    return view_inventory().to_markdown(), plot_inventory_status()

def gradio_auto_restock(product):
    restock_data, message = auto_restock(product)
    if restock_data:
        return f"Before Restock: {restock_data['before']} units\nAfter Restock: {restock_data['after']} units", plot_inventory_status()
    return message, plot_inventory_status()

# Gradio Interface Setup
# Gradio Interface
risk_interface = gr.Interface(
    fn=gradio_predict_risk,
    inputs=[
        gr.Slider(0, 1, step=0.1, label="Inventory Level"),
        gr.Slider(0, 100, step=1, label="Lead Time (days)"),
        gr.Slider(-1, 1, step=0.1, label="News Sentiment"),
        gr.Slider(-1, 1, step=0.1, label="Textual Risk"),
    ],
    outputs=["text", "text"],
    title="Risk Prediction"
)

inventory_interface = gr.Interface(
    fn=gradio_update_inventory,
    inputs=[
        gr.Text(value="semiconductors", label="Product"),
        gr.Number(label="New Stock"),
    ],
    outputs=["json", "text"],
    title="Update Inventory"
)

damage_interface = gr.Interface(
    fn=gradio_log_damage,
    inputs=[
        gr.Text(value="semiconductors", label="Product"),
        gr.Number(label="Damaged Quantity"),
    ],
    outputs=["json", "text"],
    title="Log Damaged Stock"
)

transport_delay_interface = gr.Interface(
    fn=gradio_log_transport_delay,
    inputs=[
        gr.Text(value="semiconductors", label="Product"),
        gr.Number(label="Delay Days"),
    ],
    outputs=["json", "text"],
    title="Log Transport Delay"
)

sales_interface = gr.Interface(
    fn=gradio_log_sales,
    inputs=[
        gr.Text(value="semiconductors", label="Product"),
        gr.Number(label="Sales Quantity"),
    ],
    outputs=["json", "text"],
    title="Log Sales Performance"
)

view_inventory_interface = gr.Interface(
    fn=gradio_view_inventory,
    inputs=[],
    outputs=["text", "image"],
    title="View Inventory Status"
)
restock_interface = gr.Interface(fn=gradio_auto_restock, inputs=["text"], outputs=["text", "image"], title="Auto Restock")

# Combine Interfaces
gr.TabbedInterface(
    [risk_interface, inventory_interface, damage_interface, transport_delay_interface, sales_interface, view_inventory_interface, restock_interface],
    ["Risk Prediction", "Update Inventory", "Log Damaged Stock", "Log Transport Delay", "Log Sales", "View Inventory", "Auto Restock"]
).launch()